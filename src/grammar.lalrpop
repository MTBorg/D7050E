grammar;

use std::str::FromStr;

use crate::{
	parsing::expr_parser::Opcode,
	parsing::bool_expr_parser::BoolOpcode,
	node::Node,
	func::FuncDec,
	func_param::FuncParam,
};


Identifier: String = {
	r"_*[a-z]+\w*" => <>.to_string()
}

pub Expr: Box<Node> = {
    Expr ExprOp Factor => Box::new(Node::Op(<>)),
    Factor,
};

ExprOp: Opcode = { 
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Node> = {
    Factor FactorOp Term => Box::new(Node::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Node> = {
    Num => Box::new(Node::Number(<>)), 
		Var => Box::new(Node::Var(<>)),
    "(" <Expr> ")"
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Var = Identifier;

pub FuncCall: Box<Node> = {
	<func_name:Identifier> "(" <args:FuncArgs> ")" ";"? =>	
		Box::new(
			Node::FuncCall(
				func_name,
				args,
				None
			)
		)
};

FuncArgs: Vec<String> = {
	<args:(<FuncArg> ",")*> <arg:FuncArg?> => match arg{
		Some(arg) => {
			let mut args = args;
			args.push(arg);
			args
		},
		None => args
	}
};

FuncArg: String = {
	Identifier,
	Num => <>.to_string()
};
	
FuncName = Identifier;

FuncParam: FuncParam = {
	<name:Identifier> ":" <mutable:"&"?> <_type:Type> => FuncParam{
		name: name,
		_type: _type.to_string(),
		mutable: match mutable{
			Some(_) => true,
			None => false
		}
	}
};

FuncParams: Vec<FuncParam> = {
	<params:(<FuncParam> ",")*> <param:FuncParam?> => match param{
		Some(param) => {
			let mut params = params;
			params.push(param);
			params
		},
		None => params
	}
};

pub FuncDec: FuncDec = {
	"fn" <name:FuncName> "(" <params:FuncParams> ")" <ret_type:("->" <Type>)?> "{}" => FuncDec{
		name: name,
		params: params,
		ret_type: match ret_type{
			Some(ret_type) => ret_type,
			None => "".to_string()
		}
	}
};

pub Let: Box<Node> = {
	"let" <id:Identifier> <_type:(":" <Type>)?> "=" <expr:Expr> ";"=> 
		Box::new(
			Node::Let(
				Box::new(Node::Var(id)),
				expr,
				None
			)
		),
};

Instruction: Box<Node> = {
	Let,
	If
};

Instructions: Box<Node> = {
	<mut i1:Instruction> <i2:Instructions?> => match i2{
		Some(node) => {
			i1.attach_right_most_child(*node);
			i1
		},
		None => {
			i1
		}
	}
};

pub Body: Box<Node> = {
	"{" <Instructions?> "}" => match <>{
		Some(node) => node,
		None => Box::new(Node::Empty)
	}
};

pub If: Box<Node> = {
	"if" <expr:BoolExpr> <body:Body> => Box::new(
		Node::If(
			expr,
			body,
			None,
			None
		)
	),
	"if" <expr:BoolExpr> <then_body:Body> "else" <else_body:Body> => Box::new(
			Node::If(
				expr,
				then_body,
				Some(else_body),
				None
			)
	)
};

Bool: bool = {
	"true" => true,
	"false" => false
};

pub BoolExpr: Box<Node> = {
	BoolExpr LogOp BoolFactor => Box::new(Node::BoolOp(<>)),
	BoolFactor,
};

LogOp: BoolOpcode = {
	"&&" => BoolOpcode::AND,
	"||" => BoolOpcode::OR
};

BoolFactor: Box<Node> = {
	Bool => Box::new(Node::Bool(<>)),
	Var => Box::new(Node::Var(<>)),
	RelExpr
};

RelOp: BoolOpcode = {
	"==" => BoolOpcode::EQ,
	"!=" => BoolOpcode::NEQ,
};

RelExpr: Box<Node> = {
	RelExprTerm RelOp RelExprTerm => Box::new(Node::BoolOp(<>)),
}

RelExprTerm: Box<Node> = {
	Bool => Box::new(Node::Bool(<>)),
	Expr,
}

// TODO: This should use a type enum instead
Type: String = {
	"bool" => <>.to_string(), 
	"i32" => <>.to_string(), 
}
