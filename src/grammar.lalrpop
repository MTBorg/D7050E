grammar;

use std::{
	str::FromStr,
	collections::HashMap
};

use crate::{
	parsing::expr_parser::Opcode,
	node::Node,
	func::FuncDec,
	func_param::FuncParam,
};

pub File: HashMap<String, FuncDec> = {
	<mut func_decs:FuncDec+> => {
		let mut hmap = HashMap::new();
		for func_dec in func_decs.drain(..){
			hmap.insert(func_dec.name.to_string(), func_dec);
		}
		hmap
	}
};
	

Identifier: String = {
	r"_*[a-z]+\w*" => <>.to_string()
}

pub Expr: Box<Node> = {
    Expr ExprOp Factor => Box::new(Node::Op(<>)),
    Expr LogOp Factor => Box::new(Node::Op(<>)),
    Factor,
};

LogOp: Opcode = {
	"&&" => Opcode::And,
	"||" => Opcode::Or,
};

ExprOp: Opcode = { 
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Node> = {
    Factor FactorOp Term => Box::new(Node::Op(<>)),
    Factor RelOp Term => Box::new(Node::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

RelOp: Opcode = {
	"==" => Opcode::Eq,
	"!=" => Opcode::Neq,
};

Term: Box<Node> = {
    Num, 
		Var,
		Bool,
    "(" <Expr> ")"
};

Num: Box<Node> = {
    r"-?[0-9]+" => Box::new(Node::Number(i32::from_str(<>).unwrap()))
};

Var: Box<Node> = {
	Identifier => Box::new(Node::Var(<>))
};

pub FuncCall: Box<Node> = {
	<func_name:Identifier> "(" <args:FuncArgs> ")" ";"? =>	
		Box::new(
			Node::FuncCall(
				func_name,
				args,
				None
			)
		)
};

FuncArgs: Vec<String> = {
	<args:(<FuncArg> ",")*> <arg:FuncArg?> => match arg{
		Some(arg) => {
			let mut args = args;
			args.push(arg);
			args
		},
		None => args
	}
};

FuncArg: String = {
	Identifier,
	Num => match *<> {
		Node::Number(n) => n.to_string(),
		_ => panic!("Error: Could not parse function arg number")
	}
};
	
FuncName = Identifier;

FuncParam: FuncParam = {
	<name:Identifier> ":" <mutable:"&"?> <_type:Type> => FuncParam{
		name: name,
		_type: _type.to_string(),
		mutable: match mutable{
			Some(_) => true,
			None => false
		}
	}
};

FuncParams: Vec<FuncParam> = {
	<params:(<FuncParam> ",")*> <param:FuncParam?> => match param{
		Some(param) => {
			let mut params = params;
			params.push(param);
			params
		},
		None => params
	}
};

pub FuncDec: FuncDec = {
	"fn" <name:FuncName> "(" <params:FuncParams> ")" <ret_type:("->" <Type>)?> <body_start:Body> => FuncDec{
		name: name,
		params: params,
		ret_type: match ret_type{
			Some(ret_type) => ret_type,
			None => "".to_string()
		},
		body_start: *body_start
	}
};

pub Let: Box<Node> = {
	"let" <id:Identifier> <_type:(":" <Type>)?> "=" <expr:Expr> ";"=> 
		Box::new(
			Node::Let(
				Box::new(Node::Var(id)),
				expr,
				None
			)
		),
};

Instruction: Box<Node> = {
	Let,
	If,
	FuncCall
};

Instructions: Box<Node> = {
	<mut i1:Instruction> <i2:Instructions?> => match i2{
		Some(node) => {
			i1.attach_right_most_child(*node);
			i1
		},
		None => {
			i1
		}
	}
};

pub Body: Box<Node> = {
	"{" <Instructions?> "}" => match <>{
		Some(node) => node,
		None => Box::new(Node::Empty)
	}
};

pub If: Box<Node> = {
	"if" <expr:Expr> <body:Body> => Box::new(
		Node::If(
			expr,
			body,
			None,
			None
		)
	),
	"if" <expr:Expr> <then_body:Body> "else" <else_body:Body> => Box::new(
			Node::If(
				expr,
				then_body,
				Some(else_body),
				None
			)
	)
};

Bool: Box<Node> = {
	"true" => Box::new(Node::Bool(true)),
	"false" => Box::new(Node::Bool(false))
};

// TODO: This should use a type enum instead
Type: String = {
	"bool" => <>.to_string(), 
	"i32" => <>.to_string(), 
}
